import {stripIndent} from 'common-tags'
import camelCase from 'lodash.camelcase'
import {z} from 'zod'

import {ZodToTypescriptMapper, type ZodToTypescriptMapperTarget} from '../language-mappers/zod-to-typescript-mapper.js'
import {ZodToTypescriptReturnValueMapper} from '../language-mappers/zod-to-typescript-return-value-mapper.js'
import {BaseTypescriptGenerator} from './base-typescript-generator.js'

export class ReactTypeScriptGenerator extends BaseTypescriptGenerator {
  declarationGenerate(): string {
    return stripIndent`
    /* eslint-disable */
    // AUTOGENERATED by reforge-cli's 'gen' command
    import "@reforge-com/javascript";
    import "@reforge-com/react";

    declare module "@reforge-com/javascript" {
      export interface FrontEndConfigurationRaw {
        ${this.generateSchemaTypes('raw').join('\n        ') || '// No types generated'}
      }

      // Force TypedFrontEndConfigurationRaw to always use our merged interface
      export type TypedFrontEndConfigurationRaw = FrontEndConfigurationRaw;
    }

    declare module "@reforge-com/react" {
      export interface FrontEndConfigurationAccessor {
        ${this.generateSchemaTypes().join('\n        ') || '// No types generated'}
      }

      // Force TypedFrontEndConfigurationRaw to always use our merged interface
      export type TypedFrontEndConfigurationAccessor = FrontEndConfigurationAccessor;
    }
    `
  }

  protected durationTypeMap(): z.ZodTypeAny {
    return z.object({ms: z.number(), seconds: z.number()})
  }

  generate(): string {
    return stripIndent`
    /* eslint-disable */
    // AUTOGENERATED by reforge-cli's 'gen' command
    import { Reforge, TypedFrontEndConfigurationRaw } from "@reforge-com/javascript"
    import { createReforgeHook, TypedFrontEndConfigurationAccessor } from "@reforge-com/react"
    ${this.additionalDependencies().join('\n') || '// No additional dependencies required'}

    export class ReforgeTypesafeReact {
      constructor(public reforge: Reforge) { }

      get<K extends keyof TypedFrontEndConfigurationRaw>(key: K): TypedFrontEndConfigurationRaw[K] {
        return this.reforge.get(key) as TypedFrontEndConfigurationRaw[K]
      }

      ${this.generateAccessorMethods().join('\n\n      ') || '// No methods generated'}
    }

    export const useReforge = createReforgeHook(ReforgeTypesafeReact)
    `
  }

  private additionalDependencies(): string[] {
    const dependencies: string[] = []
    const hasFunctions = this.filteredConfigurations().some((c) => c.hasFunction)

    if (hasFunctions) {
      dependencies.push(this.MUSTACHE_IMPORT)
    }

    return dependencies
  }

  private filteredConfigurations() {
    return this.configurations().filter(
      (config) => config.configType === 'FEATURE_FLAG' || config.sendToClientSdk === true,
    )
  }

  private generateAccessorMethods(): string[] {
    const uniqueMethods: Record<string, string> = {}
    const schemaTypes = this.filteredConfigurations().map((config) => {
      let methodName = camelCase(config.key)

      // If the method name starts with a digit, prefix it with an underscore to ensure method name is valid
      if (/^\d/.test(methodName)) {
        methodName = `_${methodName}`
      }

      if (uniqueMethods[methodName]) {
        throw new Error(
          `Method '${methodName}' is already registered. Reforge key ${config.key} conflicts with '${uniqueMethods[methodName]}'!`,
        )
      }

      uniqueMethods[methodName] = config.key

      if (config.hasFunction) {
        const returnValue = new ZodToTypescriptReturnValueMapper().resolveType(config.schema)

        return stripIndent`
          ${methodName}(): TypedFrontEndConfigurationAccessor['${config.key}'] {
                  const raw = this.get('${config.key}')
                  return ${returnValue}
                }
          `
      }

      return stripIndent`
        get ${methodName}(): TypedFrontEndConfigurationAccessor['${config.key}'] {
                return this.get('${config.key}')
              }
        `
    })

    return schemaTypes
  }

  private generateSchemaTypes(target: ZodToTypescriptMapperTarget = 'accessor'): string[] {
    const schemaTypes = this.filteredConfigurations().map((config) => {
      const mapper = new ZodToTypescriptMapper({fieldName: config.key, target})

      return mapper.renderField(config.schema)
    })

    return schemaTypes
  }
}
